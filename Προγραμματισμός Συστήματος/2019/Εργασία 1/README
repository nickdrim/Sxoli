
	Νικόλαος Δρυμούσης						Α.Μ.: 1115201500037


						ΕΡΓΑΣΙΑ 1

Εντολή compile και εκτέλεσης : Εχω δημιουργησει Makefile οποτε μπορειτε απλα να χρησιμοποιησετε την εντολη make.
Στη συνέχεια για εκτέλεση γράφετε ./diseasesMonitor και τα ορισματα με όποια σειρα θέλετε αρκει μετα απο τα -h1 -h2 -p -b να ειναι τα αντιστοιχα δεδομενα οπως αναφερει η εκφωνηση.

Η ασκηση εχει ελεγχθει με το script και τρεχει σωστα σε καθε περιπτωση καθως επισης και απελευθερωνει ολη τη μνημη που χρησιμοποιει με επιτυχια , οπως θα διαπηστωσετε αν χρησιμοποιησετε το valgrind.

Το προγραμμα αποτελειται απο 10 αρχεια ( 5.c και 5.h) και εχουν χωριστει αναλογα με τις συναρτησεις και τα struct που περιεχουν αντιστοιχα.

Η main του προγραμματος βρισκεται στο diseaseMonitor.c και περιεχει μονο ελεγχους για τα arguments που θα περασει ο χρηστης στο προγραμμα ενω στο τελος καλει τη menu συναρτηση που βρισκεται στο help.c.

Στο help.c βρισκονται ολες οι συναρτησεις που θελει η ασκηση να ορισουμε. Στη menu συναρτηση της help καλουνται οι συναρτησεις για αρχικοποιηση των δομων δεδομενων που χρειαζονται καθως επισης ειναι και η συναρτηση που εχει την getline που διαβαζει την εισοδο του χρηστη. Ο ελεγχος του string που δινει ο χρηστης γινεται με tokens και το καθε τοκεν που προκυπτει απο την strtok αποθηκευεται σε εναν πινακα arr.
Μετα ελεγχεται το πρωτο κελι του πινακα και αναλογα με το string που περιεχει εκτελειται η αντιστοιχη λειτουργια του προγραμματος.

Η insert στη λιστα γινεται με τη βοηθεια pointer που διχνει στο τελευταιο κομβο της λιστας ωστε να ειναι γρηγορη η εισαγωγη.

Στην initialize των hash table γινετε αρχικοποιηση και καποιοων global μεταβλητων που ειναι χρησιμες σε πολλες συναρτησεις και εγιναν global για να μηχρειαζεται να περνιουνται σαν ορισμα συνεχεια στις συναρτησεις. 2 απο αυτες τις μεταβλητες κρατανε το μεγεθος των hash table ενω η τριτη οριζει το ποσα αντικειμενα μπορουν να αποθηκευτουν σε ενα bucket(itemArraySize)

Ωσων αφορα τη διαδικασια εισαγωγης σε hash table ειναι η εξης:

1.Βρισκουμε το hash value του string και κοιταμε το αντιστοιχο κελι του πινακα.
2.Αν το κελι ειναι αδειο δημιουργουμε bucket και κανουμε την εισαγωγη εκει.
3.Αν δεν ειναι αδειο κοιταμε να δουμε αν το string υπαρχει ηδη μεσα στο bucket.Ανυπαρχει το εισαγουμε εκει
4.Αν δεν υπαρχει υπαχρουν τρεις περιπτωσεις.
4α.Το bucket δεν ειναι ακομα γεματο οποτε αυξανουμε το counter του και το εισαγουμε εκει.
4β.Το bucket ειναι γεματο και το link ειναι αδειο.Οποτε δημιουργουμε καινουργιο bucket στο link και το εισαγουμε
4γ.Το bucket ειναι γεματο και το link δεν ειναι αδειο.Στην περιπτωση αυτη ψαχνουμε καθε bucket.
5α.Βρισκουμε το string σε ενα απο αυτα τα bucket και το εισαγουμε.
5β.Εχουμε φτασει στο τελευταιο bucket και δεν εχει βρεθει η τιμη.Οποτε μετα ουσιαστικα κοιταμε παλι 4α και 4β περιπτωσεις.

Το Binary search tree που εφτιαξα ειναι avl δεντρο που περιεχει πληροφοριες για το υψος του , ενα date , εναν pointer σε record και δυο pointers στα παιδια του.

Οσων αφορα το heap η υλοποιηση του εχει γινει χωρις τη βοηθεια πινακα αλλα με τη βοηθεια ουρας και λειτουργει ως εξης:

Η heapInsert αρχικα εξασφαλιζει οτι το δεντρο ειναι complete με τη βοηθεια της ουρας που αποθηκευει εναν κομβο μεχρι να γεμισουν τα παιδια του και η εισαγωγη γινεται παντα πρωτα στο αριστερο παιδι και μετα στο δεξι.Μετα χρησιμοποιειται η συναρτηση heapify που μετατρεπει το complete δεντρο σε heap με τη βοηθεια της levelorder και απο το γεγονος οτι ο κομβος που πρεπει να ξεκινησουμε να ελεγχουμε δινεται απο των συνολικο αριθμο των κομβων δια 2. Οποτε με τη levelorder φτανουμε στον κομβο n αυτο και ξεκιναμε τις συγκρισεις και τις αλλαγες. Μετα η διαδικασια γινεται για τον κομβο στη θεση n-1 μεχρι τη ριζα.Σε πολυ μεγαλο δεντο θα αυτη η διαδικασια δεν θα ειναι αρκετη οποτε μετα ελεγχεται αν το δεντρο ειναι heap και αν δεν ειναι ξαναξεκιναει διαδικασια heapify αλλα αυτη τη φορα δινεται το υποδεντρο του αρχικου δεντρου με ριζα τον κομβο που αλλαξε τελευταιος.Η διαδικασια αυτη επαναλαμβανεται για ολα τα υποδεντρα ή μεχρι το αρχικο δεντρο να ειναι.

Αλλες σημειωσεις ειναι οτι εχω χρησιμοποιησει μια variadic συναρτηση για τη globalDiseaseStats και θα μπορουσα να κανω το ιδιο και με τις αλλες αλλα δεν εβρισκα λογο για αυτη την υλοποιηση μετα και ηταν πολυ πιο ευκολο να περναω απλα ορισματα ως null.

Μετα την δημοσιευση του script αναγκαστικα να αλλαξω τα print του προγραμματος μου αλλα αν ελετε να δειτε πιο ευχριστα πληροφοριες τα εχω αφησει σε comments μεσα στον κωδικα οποτε απλα καντε uncomment.
Πιθανος αλλα λογικα δεν υπαρχει θεμα με τις αλλαγες καποιο print να προκαλει segmentation γιατι αλλαξε ο κωδικας ωστε να ικανοποιει το script.Κατα τα αλλα το προαγραμμα τρεχει κανονικα.

Τελος υπαρχουν αρκετες συναρτησεις για το size ενως δεντρο αλλα αυτο φταιει οτι αλλαζε καποια συνθηκη αναλογα με το τι θελουμε να βρουμε.
