Νικόλαος Δρυμουσης									Α.Μ:1115201500037
						PROJECT 2
						
Περιεχόμενα:

Η ασκηση αποτελειται απο 20 αρχεια:
11.c αρχεια
7.h αρχεια
1.sh αρχειο
1 Makefile

Εντολη μεταγγλωτισης και εκτελεσης:

Για compile απλα γραφεται make εφοσων υπαρχει makefile και γινονται compile και το ./monitor
και το ./travelMonitor

Για εκτελεση γραφεται:
	./travelMonitor –m numMonitors -b bufferSize -s sizeOfBloom -i input_dir
οπου τα flags μπορει να ειναι με διαφορετικη σειρα αρκει να ακολουθουνται απο το καταλληλο ορισμα

Memory leaks:
	Το προγραμμα εχει ελεγθει με valgrind και σε ωσες περιπτωσεις εχω ελεγξει απελευθερώνει με επιτυχία
	ολη τη μνημη που δεσμευει.

Σχεδιαστικες επιλογες:
	Σε γενικες γραμμες το Μοnitor ειναι ιδιο με το vaccineMonitor της ασκησης 1 καθως
	χρησιμοποιηει τα ιδια structs για να αποθηκευση τις πληροφοριες που διαβαζει απο τα αρχεια.
	
	Το προγραμμα γενικα επιτρεπει οποιαδηποτε μη αρνητικη και μη μηδενικη τιμη του buffer
	καθως επισης και οποιοδηποτε μεγεθος για bloomfilter.Πολλες απο τις μεταβλητες στο 
	travelMonitor ειναι global. Αυτο γινεται ωστε να μπορουν να απελευθερωθει η μνημη που
	δεσμευουν σε περιπτωση ενος SIGINT αλλα επισης και γιατι αυτες οι μεταβλητες ειναι χρησιμες
	σε παρα πολλες συναρτησεις.Μερικες απο αυτες τις μεταβλητες ειναι ενας πινακας στον οποιο
	αποθηκευουμε τα process id των child processes, ενας πινακας που αποθηκευουμε τα process id
	των αρχικων child process(αυτο θα ειναι σημαντικο μετα), ενας πινακας που αντιστοιχει το index
	του με το read fifo file του process id(ετσι πχ pids[i] αντιστοιχει στο read_fifos[i]),ενα
	τετοια array για write fifo file. Ακομα ειανι και δυο πολυ σημαντικες δομες global. Η μια
	ειναι ενα hash table για τα process ids και πληροφοριες που συχετιζονται με αυτα οπως τα
	directories που χειριζονται, τις χωρες, τα αρχεια read write και το index των προηγουμενων
	global array ωστε να μπορουμε απο ενα process id να δουμε ποιο κελι στα παραπανω array 
	αντιστοιχει σε αυτο.Τελος υπαρχει και μια δομη που λειτουργει σαν καταλαγος για χωρες
	και περιεχει και το process id της διεργασιες που τη διαχειριζεται.Ετσι απο μια χωρα 
	μπορουμε να βρουμε το process id και απο το process id ολες τις υπολοιπες πληροφοριες.
	
	Ξεκινωντας λοιπον η εφαρμογη ελεγχει την ορθοτητα των arguments που δωσαμε στην εντολη
	εκτελεσης.Στη συνεχει αρχικοποιει τον signal handler καθως επισης και οτι χρειαζομαστε για
	τη συναρτηση sigwait().Στη συνεχει για ολα τα παιδια που θα δημιουργησει φτιαχνει ενα 
	read fifo και ενα write και τα περναει σαν ορισματα μολις κανει fork.Μετα περιμενει το
	child process να αρχικοποιησει τις δικες του τιμες και μολις λαβει σημα,συσχετιζει τα global
	variables με τη τιμη του child process αυτου οπως αναφερα παραπανω.

	Αφου ολοκληρωσει τη παραπανω διαδικασια για ολα τα παιδια, κανει navigate στον input directory
	που δοθηκε ως ορισμα. Και κανει initialize της παραπανω συο σημαντικες δομες(pid hash table,
	country catalog),οπου τα ονοματα των φακελων που διαβαζει ειναι οι χωρες για τις οποιες το προγραμμα
	θα διαχειριζεται.Καθε ενα φακελο που βλεπει το στελνει στο επομενο child process να το διαχειριστει.
	Ετσι τα child process εχουν το πολυ ενα directory διαφορα σε αυτα που διαχειριζονται.
	
	Προτοκολο επικοινωνιας:
	
	Με το που δωσει το σημα το parent process οτι ειναι ετοιμο να διαβασει αρχεια απο τα child process
	στελνει ενα σημαν SIGUSR1 σε αυτα και ξεκινανε να διαβαζουν τα read fifo αρχεια τους και να κανουν
	initialize τις δομες τους οπως και στην ασκηση 1. Εντομεταξυ το parent process περιμενει ποτε θα ειναι
	ετοιμο ενα file descriptor να διαβαστει με τη χρηση της poll. Μολις ενα child process ειναι ετοιμο
	να στειλει στο parent process αρχικα στελνει των αριθμο των bytes που θα στειλει και μετα περιμενει
	σημα απο τον γονεα οτι το διαβασε για να συνεχησει.Μολις ο γονεας διαβασει στελνει σημα στο παιδι
	και περιμενει το επομενο γραψιμο.Στη συνεχεια το παιδι στελνει τον ιο ωστε να ξερει το parent process
	που απευθυνεται το bloom filter που θα λαβει.Το παιδι γραφει τον ιο και περιμενει παλι.Ο γονεας διαβαζει το
	ονομα και περιμενει το επομενο γραψιμο.Το παιδι γραφει το size του bloom filter και περιμενει.Ο γονεας το
	διαβαζει και περιμενει.Το παιδι περναει το bloom filter και στελνει signal στον γονεα να διαβασει.Επειδη ειναι
	το τελευταιο γραψιμο το παιδι δεν περιμενει και συνεχιζει και περιμενει να ξαναερθει η σειρα του ωστα να
	επαναληφθει η παραπανω διαδικασια.Ο γονεας απο τη μερια του διαβαζει το bloom filter και το στελνει στο
	hash table για τα processes ωστε να εισαγει το bloom filter και τον ιο σε καθε χωρα που διαχειριζεται.
	
	
	Αξιζει να σημειωθει οτι για bloom_filter με μεγεθος μεγαλυτερο απο 10000 bytes. Το child process το 
	στελνει σε κωμματια στο parent process για να μη περασουμε το μεγεθος που μπορει να μεταφερει ενα pipe
	και μπλοκαρει.Αυτος ειναι κυριως ο λογος που γινεται ετσ η επικοινωνια καθως αν το παιδι απλα εγραφε συνεχεια
	και δεν περιμενε τον γονεα να διαβασει αυτο που εστειλε πριν συνεχισει, το pipe θα εφτανε το maximum capacity
	του και θα μπλοκαρε.
	
	Μετα το parent process περιμενει απο το χρηστη εντολη για εκτελεση.
	
	/travelRequest:
	
	Αρχικα το parent process ελεγχει το bloom filter για τον ιο και τη χωρα αυτη.Αν προκυψει οτι το 
	citizen id δεν περιεχεται στο bloom filter εκτυπωνει το μηνυμα που αναφερεται στην εκφωνηση.Ωστοσο
	αν υπαρχει απο τη συναρτηση που καναμε το check μας γυριζει και το index του process που διαχειριζεται
	αυτη τη χωρα και ετσι εχουμε προσβασει σε ολα τις πληροφοριες που θελουμε απο τα global variable.Στη 
	συνεχει στελνει SIGUSR2 ωστε να ενεργοποιηθει το αντιστοιχο Monitor και να διαβασει της πληροφοριες 
	που θα του μεταφερει το parent process.Αυτο ελεγχει τις δομες του και επιστρεφει ειτε "NO" ειτε
	"YES DD-MM-YYYY". Το parent process στη περιπτωση του YES ελεγχει αν η διαφορα στις ημερομηνιες ειναι
	μικροτερη απο 6 μηνες.Αυτο το κανει μετατρεποντας τις ημερομηνιες σε μερες και αφαιρωντας τη μια με
	την αλλης. Αν το αποτελεσμα ειναι μικροτερο απο 180 (μερες) τοτε απανταει θετικα αν οχι αρνητικα.
	
	Σημειωσει: το hash table για processes περιεχει επεισης ενα hash table για τις χωρες.Καθε κομβος του
	περιεχει το ονομα της χωρας και μια λιστα απο τους ιους. Αυτη η λιστα περιεχει το bloom filter του αντιστοιχου
	ιου το ονομα της ασθενειας και τελος μια ακομα δομη λιστας για τα αιτηματα.Οι κομβοι αυτης της λιστας αποτελουνται
	απο μια ημερομηνια και μια μεταβλητη int answer η οποια ειναι ειτε 0 ειτε 1, υποδηλωνωντας εγκριση ή οχι.H λιστα
	αυτη ειναι ταξινομημενη με βαση την ημερομηνια απο μικροτερη σε μεγαλυτερη.
	Στο τελος της travelRequest για τη χωρα και τον ιο το αποτελεσμα αποθηκευεται σε αυτη τη λιστα.
	
	/travelStats:
	
	Αυτη η συναρτηση πηγαινει στη παραπανω λιστα των request και επειδη η λιστα ταξινομημενη μπορει ευκολα
	να βρει τον συνολικο αριθμο για καθε κατηγορια.Υπαρχουν σχολια και στο κωδικα για πως το κανει
	για καθε χωρα ή μονο για μια.
	
	/addVaccinationRecords:
	
	Η συναρτηση αυτη απλα στελνει ενα SIGUSR1 στο αντιστοιχο process id που διαχειριζεται τη χωρα
	και επεναλαμβανει το προτοκολο επικοινωνιας που αναφερθηκε πιο πανω.Ετσι κανει update τα bloom filter.
	
	/searchVaccinationStatus
	
	Η συναρτηση αυτη στελνει ενα SIGUSR2 στο αντιστοιχο process id που διαχειριζεται τη χωρα
	και διαβαζει αμεσως οτι της στειλει το child process το οποιο κανει μια αντιστοιχει λειτουργια με
	αυτη της αντιστοιχης εντολης στο project 1
	
Signal handler:
	
	SIGINT:
	
	ενα global termination_flag γινεται raise και στη συνεχεια κοιταει με τη βοηθεια ενος command_flag
	αν τη στιγμη που ηρθε το sigint εκτελουσε το parent process καποια εντολη.Αν αυτο το flag ειναι
	raised τοτε γυριζει απλα πισω σηκωνοντας ενα global sigint_flag. Μολις τελειωσει την εκτελεση της 
	εντολης το parent process βλεπει οτι εχει γινει raise to sigint_flag και ξαναστελνει SIGINT σημα
	στον ευατο του. Αυτη τη φορα αποδεσμευεται ολη η μνημη, στελνει SIGKILL στα childprocess, διαγραφει
	τα fifo files και καποια αλλα προσωρινα αν υπαρχουν και τελειωνει την εκτελεση του.
	
	SIGCHLD:
	
	Αν το termination flag ειναι raised τοτε ο handler απλα το αγνοει. Αν ομως δεν ειναι η ωρα να τερματησει
	το προγραμμα τoτε με τη βοηθεια της wait βρισκουμε πιο παιδι εχει τερματησει και απο το hash table των
	processes ανακτουμε ολες της πληροφοριες που σχετιζονται με αυτο το παιδι καθως επισης και το index του
	για τα global variables στη συνεχεια κανουμε fork και παιρναμε της πληροφοριες αυτες στο νεο process και 
	στη συνεχεια αντικαθιστουμε αυτο το id με το νεο process id και συσχετιζουμε τα global variables με αυτο
	το id(και τον καταλογο με τις χωρες). Το νεο process θα αρχικοποιηθει και θα ειναι εχει ακριβως τα ιδια
	στοιχει με το προηγουμενο process.Αυτο γινεται γιατι στην αρχικη επικοινωνια του parent process με τα 
	child processes για την αρχικοποιησει του bloom filter, καθε ενα απο αυτα τα παιδια δημιουργησε ενα
	αρχειο που αντεγραψε τα μονοπατια ολων των directories που ειχε στειλει ο γονεας στο αρχικο παιδι.Ετσι
	αυτο αυτη τη φορα διαβαζει αυτο το αρχει και οχι τα pipes. To terminanated_pids array για αυτο κραταει
	τα id των αρχικων child process ωστε τα καινουργια που παιρνουν τη θεση να ξερουν πιο αρχειο θα διαβασουν
	εφοσων το ονομα του ειναι στη μορφη process_id.txt. Ωσες φορες και να τερματησει ενα παιδι παντα θα
	εχουμε ενα copy του.
	
	Τα αλλα signals διαχειριζονται κυριως flags με εξαιρεση το SIGSEGV που απλα διαγραφει τα αρχει που δημιουργηθηκαν
	απο τον φακελο.


Μonitor:

	Το Monitor μοιαζει με αυτο της ασκησης 1. Με τη διαφορα οτι υπαρχει ενα νεο hash table για τα directories
	που διαχειριζεται το process.Αυτο περιεχει το fullpath στο directory, το ονομα της χωρας αυτου του directory
	τον αριθμο των αρχειων και τα αρχεια που περιεχει.Λειτουργει σαν ενας αντιστοιχος καταλογος σαν αυτον με τις
	χωρες που εχει το travelMonitor.Επισης εχει μερικες global μεταβλητες οπως και το travelMonitor που μπορει να
	σχετιζονται με τον αν ειναι η πρωτη φορα που εκτελουνται(το οποιο το παιρναει σαν argument me exec το parent
	process) τα write/read fifos, to file πουα ενεφερα και ποιο πανω στο SIGCHLD και τις δομες που χρειαζεται.
	Με το SIGINT εχω βαλει το παιδι να κανει log_file και να τερματιζει.
	
Bash script:

To script κανει ελεγχο για να δει αν τα ορισματα ειναι σωστα.
Αρχικα διαβαζει το Inputfile γραμμη γραμμη.Εντοπιζει το country και το βαζει σε ενα assosiative array που το κανει
assosiate με εναν αριθμο που υποδηλωνει σε ποιο απο τα αρχει θα βαλει αυτην την εγραφη.Αν δεν υπαρχει δημιουργει τον φακελο
κανει cd σε αυτον και δημιουργει το νεο αρχειο ή προσθετει στο ηδη υπαρχων.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
