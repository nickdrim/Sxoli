Νικόλαος Δρυμουσης									Α.Μ:1115201500037
						PROJECT 3
						
Περιεχόμενα:

Η ασκηση αποτελειται απο 20 αρχεια:
11.c αρχεια
8.h αρχεια
1 Makefile

Εντολη μεταγγλωτισης και εκτελεσης:

Για compile απλα γραφεται make εφοσων υπαρχει makefile και γινονται compile και το ./monitorServer
και το ./travelMonitorClient

Για εκτελεση γραφεται:
	./travelMonitorClient –m numMonitors -b bufferSize -c cyclicBufferSize -s sizeOfBloom -i 
	input_dir -t numThreads

	οπου τα flags μπορει να ειναι με διαφορετικη σειρα αρκει να ακολουθουνται απο το καταλληλο ορισμα

Memory leaks:
	Το προγραμμα εχει ελεγθει με valgrind και σε ωσες περιπτωσεις εχω ελεγξει απελευθερώνει με επιτυχία
	ολη τη μνημη που δεσμευει.
	
Σχεδιαστικες επιλογες:

	Σε γενικες γραμμες το travelMonitorClient ειναι ιδιο με αυτο της ασκησης 2 προσαρμοσμενο
	πλεον στο να χειριζεται socket και βγαζοντας καποιες απο τις λειτουργιες των signals
	αφου πλεον δεν χρειαζεται να τα χειριζεται με τον ιδιο τροπο.
	
	Το προγραμμα γενικα επιτρεπει οποιαδηποτε μη αρνητικη και μη μηδενικη τιμη του buffer
	καθως επισης και οποιοδηποτε μεγεθος για bloomfilter.Πολλες απο τις μεταβλητες στο 
	travelMonitor ειναι global. Αυτο γινεται ωστε να μπορουν να απελευθερωθει η μνημη που
	δεσμευουν σε περιπτωση ενος SIGINT αλλα επισης και γιατι αυτες οι μεταβλητες ειναι χρησιμες
	σε παρα πολλες συναρτησεις.Μερικες απο αυτες τις μεταβλητες ειναι ενας πινακας στον οποιο
	αποθηκευουμε τα process id των child processes, ενας πινακας που αποθηκευουμε τα process id
	των αρχικων child process(αυτο θα ειναι σημαντικο μετα), ενας πινακας που αντιστοιχει το index
	του με το socket fd του process id(ετσι πχ pids[i] αντιστοιχει στο socket_fds[i])
	Ακομα ειανι και δυο πολυ σημαντικες δομες global. Η μια ειναι ενα hash table για τα process ids
	και πληροφοριες που συχετιζονται με αυτα οπως τα directories που χειριζονται, τις χωρες, τo fd
	του socket και το index των προηγουμενων global array ωστε να μπορουμε απο ενα process id να δουμε
	ποιο κελι στα παραπανω array αντιστοιχει σε αυτο.Τελος υπαρχει και μια δομη που λειτουργει σαν καταλαγος
	για χωρες και περιεχει και το process id της διεργασιες που τη διαχειριζεται.Ετσι απο μια χωρα 
	μπορουμε να βρουμε το process id και απο το process id ολες τις υπολοιπες πληροφοριες.
	Στις global μεταβλητες εχει προστεθει και ενας τρισδιαστατος πινακας argument_array,
	ο οποιος αποθηκευει τους argument πινακες που θα περασουμε σε καθε παιδι μεσω της
	execv. Οι 6 πρωτες θεσεις καθε argument πινακα θα ειναι ιδιες και θα περιεχουν πληροφοριες
	οπως τον αριθμο του PORT, το μεγεθος του cyclic buffer, τον αριθμο των threads κτλπ.Οι 
	υπολοπες θεσεις θα ειναι τα μονοπατια των χωρων που θα διαχειριζεται το αντιστοιχο process.
	
	Ξεκινωντας λοιπον η εφαρμογη ελεγχει την ορθοτητα των arguments που δωσαμε στην εντολη
	εκτελεσης.Στη συνεχει αρχικοποιει τον signal handler καθως επισης και οτι χρειαζομαστε για
	τη συναρτηση sigwait().Στη συνεχεια κανει initialize τις αρχικες τιμες του argument_array,
	οπως αναφερθηκε πιο πανω, καθως επισης και δημιουργει το socket και βρισκει το local ip.
	Επειτα κανει navigate τα directories και με round robin βαζει το μονοπατι στο αντιστοιχο
	argument array.Σε αυτη τη φαση γινεται Initialized και ο καταλαγος των χωρων.Ομως επειδη
	δεν εχουμε κανει ακομα exec και δεν ξερουμε τα process id των διεργασιων αποθηκευουμε 
	προσωρινα σαν υπευθυνο id για τη διαχειρηση της εκαστοτε χωρας των αριθμου του round robin.
	Ετσι αργοτερα αφου κανουμε fork και exec για να βρουμε το υπευθυνο id απλα χρησιμοποιουμε
	τον global πινακα pids με index τον αριθμο του round robin.
	
	Προτοκολο επικοινωνιας:
	
	Το parent process αρχικα περιμενει ποτε θα ειναι ετοιμο ενα file descriptor να διαβαστει με τη χρηση της poll. 
	Μολις ενα child process ειναι ετοιμο να στειλει στο parent process αρχικα στελνει των αριθμο των bytes που θα στειλει και μετα περιμενει
	σημα απο τον γονεα οτι το διαβασε για να συνεχησει.Μολις ο γονεας διαβασει στελνει σημα στο παιδι
	και περιμενει το επομενο γραψιμο.Στη συνεχεια το παιδι στελνει τον ιο ωστε να ξερει το parent process
	που απευθυνεται το bloom filter που θα λαβει.Το παιδι γραφει τον ιο και περιμενει παλι.Ο γονεας διαβαζει το
	ονομα και περιμενει το επομενο γραψιμο.Το παιδι γραφει το size του bloom filter και περιμενει.Ο γονεας το
	διαβαζει και περιμενει.Το παιδι περναει το bloom filter και στελνει signal στον γονεα να διαβασει.Επειδη ειναι
	το τελευταιο γραψιμο το παιδι δεν περιμενει και συνεχιζει και περιμενει να ξαναερθει η σειρα του ωστα να
	επαναληφθει η παραπανω διαδικασια.Ο γονεας απο τη μερια του διαβαζει το bloom filter και το στελνει στο
	hash table για τα processes ωστε να εισαγει το bloom filter και τον ιο σε καθε χωρα που διαχειριζεται.
	
	Αξιζει να σημειωθει οτι για bloom_filter με μεγεθος μεγαλυτερο απο 10000 bytes. Το child process το 
	στελνει σε κωμματια στο parent process για να μη περασουμε το μεγεθος που μπορει να μεταφερει ενα pipe
	και μπλοκαρει.Αυτος ειναι κυριως ο λογος που γινεται ετσ η επικοινωνια καθως αν το παιδι απλα εγραφε συνεχεια
	και δεν περιμενε τον γονεα να διαβασει αυτο που εστειλε πριν συνεχισει, το pipe θα εφτανε το maximum capacity
	του και θα μπλοκαρε.
	
	Μετα το parent process περιμενει απο το χρηστη εντολη για εκτελεση.
	
	/travelRequest:
	
	Αρχικα το parent process ελεγχει το bloom filter για τον ιο και τη χωρα αυτη.Αν προκυψει οτι το 
	citizen id δεν περιεχεται στο bloom filter εκτυπωνει το μηνυμα που αναφερεται στην εκφωνηση.Ωστοσο
	αν υπαρχει απο τη συναρτηση που καναμε το check μας γυριζει και το index του process που διαχειριζεται
	αυτη τη χωρα και ετσι εχουμε προσβασει σε ολα τις πληροφοριες που θελουμε απο τα global variable.Στη 
	συνεχει στελνει SIGUSR2 ωστε να ενεργοποιηθει το αντιστοιχο Monitor και να διαβασει της πληροφοριες 
	που θα του μεταφερει το parent process.Αυτο ελεγχει τις δομες του και επιστρεφει ειτε "NO" ειτε
	"YES DD-MM-YYYY". Το parent process στη περιπτωση του YES ελεγχει αν η διαφορα στις ημερομηνιες ειναι
	μικροτερη απο 6 μηνες.Αυτο το κανει μετατρεποντας τις ημερομηνιες σε μερες και αφαιρωντας τη μια με
	την αλλης. Αν το αποτελεσμα ειναι μικροτερο απο 180 (μερες) τοτε απανταει θετικα αν οχι αρνητικα.
	
	Σημειωσει: το hash table για processes περιεχει επεισης ενα hash table για τις χωρες.Καθε κομβος του
	περιεχει το ονομα της χωρας και μια λιστα απο τους ιους. Αυτη η λιστα περιεχει το bloom filter του αντιστοιχου
	ιου το ονομα της ασθενειας και τελος μια ακομα δομη λιστας για τα αιτηματα.Οι κομβοι αυτης της λιστας αποτελουνται
	απο μια ημερομηνια και μια μεταβλητη int answer η οποια ειναι ειτε 0 ειτε 1, υποδηλωνωντας εγκριση ή οχι.H λιστα
	αυτη ειναι ταξινομημενη με βαση την ημερομηνια απο μικροτερη σε μεγαλυτερη.
	Στο τελος της travelRequest για τη χωρα και τον ιο το αποτελεσμα αποθηκευεται σε αυτη τη λιστα.
	
	/travelStats:
	
	Αυτη η συναρτηση πηγαινει στη παραπανω λιστα των request και επειδη η λιστα ταξινομημενη μπορει ευκολα
	να βρει τον συνολικο αριθμο για καθε κατηγορια.Υπαρχουν σχολια και στο κωδικα για πως το κανει
	για καθε χωρα ή μονο για μια.
	
	/addVaccinationRecords:
	
	Η συναρτηση αυτη απλα στελνει ενα SIGUSR1 στο αντιστοιχο process id που διαχειριζεται τη χωρα
	και επεναλαμβανει το προτοκολο επικοινωνιας που αναφερθηκε πιο πανω.Ετσι κανει update τα bloom filter.
	
	/searchVaccinationStatus
	
	Η συναρτηση αυτη στελνει ενα SIGUSR2 στο αντιστοιχο process id που διαχειριζεται τη χωρα
	και διαβαζει αμεσως οτι της στειλει το child process το οποιο κανει μια αντιστοιχει λειτουργια με
	αυτη της αντιστοιχης εντολης στο project 1
	
Signal handler:
	Εφοσων δεν χρειαζεται να χειριζομαστε τα signals οπως στην ασκηση 2, πλεον τα χειριζομαστε πιο απλα.
	
	SIGINT:
	
	Πλεον αν το parent process λαβει SIGINT στελνει SIGKILL στα παιδια αν ακομα δεν εχουν τελειωσει το initialize με τις δομες
	αλλιως στελνει και σε αυτα SIGINT ωστε να μπορεσουν να αποδεσμευσουν τη μνημη τους και να κανουν log_file.Προφανως υπαρχουν
	πολλες περιπτωσεις στις οποιες μπορει να ερθει ενα SIGINT οποτε δεν αποδεσμευεται παντα ολη η μνημη με επιτυχια.
	
	SIGCHLD:
	
	Το SIGCHLD πλεον μονο ειδοποιει οτι ελαβε ενα τετοι μηνημα και προτεινει στον χρηστη να τελειωσει το προγραμμα με την 
	εντολη /exit.
	
	SIGSEGV:
	
	Στελνει SIGKILL στα child process και τερματιζει την εκτελεση.
	
	
Monitor:

	Οι δομες που χρησιμοποιει ειναι οι ιδιες με την ασκηση 1.Περιεχει ενα hash table για τα directories
	που διαχειριζεται το process.Αυτο περιεχει το fullpath στο directory, το ονομα της χωρας αυτου του directory
	τον αριθμο των αρχειων και τα αρχεια που περιεχει.Λειτουργει σαν ενας αντιστοιχος καταλογος σαν αυτον με τις
	χωρες που εχει το travelMonitor.Επισης εχει μερικες global μεταβλητες οπως και το travelMonitor.
	
	Με το που ξεκινησει την εκτελεση αρχικοποιει τις τιμες των buffer, το size του βλοομ φιλτερ, των 
	αριθμο των threads που περασεμε με την exec. ΕΠειτα δημιουργει ενα socket και βρισκει το Local ip
	για να κανει connect στο socket του travelMonitorClient.Στη συνεχεια κανει initialize τις δομες του
	και δημιουργει τα threads. Μετα τα υπολοιπα argument που περασαμε μεσω της exec (paths) τα βαζει στο
	κυκλικο buffer αν δεν ειναι γεματος αλλιως περιμενε να αδειασει. Μολις τελειωσουν τα threads 
	στελνει τα bloom filter στον γονεα και περιμενει να εκτελεσει μια εντολη.
	
	Threads:
	
	Για τα threads χρησιμποιουμε τρια mutexes για τις τρεις κοινες δομες που μοιραζονται.
	Ενας ειναι για να βγαλουμε ενα αντικειμενο απο τον cyclic buffer. Eνας για να 
	εισαγουμε ενα αρχει στο directory hash table και εναν για να εισαγουμε στον
	virus hashtable της ασκησης 1. Τα thread θα τελειωσουν την εκτελεση τους
	οταν ο cyclic buffer ειναι αδειος και εχει σηκωσει ενα global falg το οποιο δηλωνει οτι δεν υπαρχουν αλλα
	μονοπατια για επεξεργασια.
	
Σημειωση: Υπαρχουν και συναρτησεις στον κωδικα που δεν χρησιμοποιουνται πλεον και ειναι απο την ασκηση 2.
	  Επισης σπανια τα process child μπλοκαρουν με το valgrind.Σε αυτη τη περιπτωση απλα ξανατρεξτε το προγραμμα.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
